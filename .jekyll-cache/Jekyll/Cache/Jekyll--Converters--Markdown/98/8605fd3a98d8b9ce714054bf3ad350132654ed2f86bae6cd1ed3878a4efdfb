I"ZI<ul id="markdown-toc">
  <li><a href="#c-复习-全新完整版" id="markdown-toc-c-复习-全新完整版">C++ 复习 全新完整版</a>    <ul>
      <li><a href="#1c与c的区别" id="markdown-toc-1c与c的区别">1、C与C++的区别</a></li>
      <li><a href="#2new的数据能用free吗" id="markdown-toc-2new的数据能用free吗">2、new的数据能用free吗？</a></li>
      <li><a href="#4new与malloc的区别" id="markdown-toc-4new与malloc的区别">4、new与malloc的区别</a></li>
      <li><a href="#5拷贝构造函数-" id="markdown-toc-5拷贝构造函数-">5、拷贝构造函数 ∞</a></li>
      <li><a href="#6main函数" id="markdown-toc-6main函数">6、main函数</a></li>
      <li><a href="#7重载重写覆盖隐藏" id="markdown-toc-7重载重写覆盖隐藏">7、<strong>重载、重写（覆盖）、隐藏</strong></a></li>
      <li><a href="#8继承和组合" id="markdown-toc-8继承和组合">8、继承和组合</a></li>
      <li><a href="#9const与define区别" id="markdown-toc-9const与define区别">9、const与define区别</a></li>
      <li><a href="#10虚函数与纯虚函数" id="markdown-toc-10虚函数与纯虚函数">10、虚函数与纯虚函数</a></li>
      <li><a href="#11继承" id="markdown-toc-11继承">11、继承</a></li>
      <li><a href="#12多态" id="markdown-toc-12多态">12、多态</a></li>
      <li><a href="#13指针和引用的区别" id="markdown-toc-13指针和引用的区别">13、指针和引用的区别</a></li>
      <li><a href="#14typedef-typename-作用" id="markdown-toc-14typedef-typename-作用">14、typedef typename 作用</a></li>
      <li><a href="#15c内存管理" id="markdown-toc-15c内存管理">15、c++内存管理</a></li>
      <li><a href="#16各类函数的比较" id="markdown-toc-16各类函数的比较">16、各类函数的比较</a></li>
      <li><a href="#17i与i" id="markdown-toc-17i与i">17、i++与++i</a></li>
      <li><a href="#18-函数指针与指针函数辨别" id="markdown-toc-18-函数指针与指针函数辨别">18、 函数指针与指针函数辨别</a></li>
      <li><a href="#18智能指针" id="markdown-toc-18智能指针">18、智能指针</a></li>
      <li><a href="#19-const-static" id="markdown-toc-19-const-static">19、 const, static</a></li>
      <li><a href="#static-" id="markdown-toc-static-">static </a></li>
      <li><a href="#20-c-stl" id="markdown-toc-20-c-stl">20、 C++ STL</a></li>
      <li><a href="#21c为什么偏底层一点link" id="markdown-toc-21c为什么偏底层一点link">21、C为什么偏底层一点link</a></li>
      <li><a href="#22递归无限执行时堆和栈是怎么溢出的" id="markdown-toc-22递归无限执行时堆和栈是怎么溢出的">22、递归无限执行时，堆和栈是怎么溢出的</a></li>
      <li><a href="#23跨平台是怎么实现的为什么能跨平台" id="markdown-toc-23跨平台是怎么实现的为什么能跨平台">23、跨平台是怎么实现的，为什么能跨平台</a></li>
      <li><a href="#24gcc和vs的区别是什么" id="markdown-toc-24gcc和vs的区别是什么">24、gcc和vs的区别是什么??</a></li>
      <li><a href="#25socket编程" id="markdown-toc-25socket编程">25、socket编程</a></li>
      <li><a href="#26进程线程调度和通信" id="markdown-toc-26进程线程调度和通信">26、进程、线程调度和通信</a></li>
      <li><a href="#27定义和声明区别" id="markdown-toc-27定义和声明区别">27、定义和声明区别</a></li>
      <li><a href="#28camke" id="markdown-toc-28camke">28、camke</a></li>
      <li><a href="#29python和c有什么区别" id="markdown-toc-29python和c有什么区别">29、python和C++有什么区别</a></li>
      <li><a href="#32异常处理" id="markdown-toc-32异常处理">32、异常处理</a></li>
      <li><a href="#36include头文件的顺序以及双引号和尖括号的区别" id="markdown-toc-36include头文件的顺序以及双引号和尖括号的区别">36、include头文件的顺序以及双引号””和尖括号的区别</a></li>
    </ul>
  </li>
</ul>

<p>C++ 复习</p>

<h2 id="c-复习-全新完整版">C++ 复习 全新完整版</h2>
<p>@(面试复习 | 终版)[C++]</p>

<h4 id="1c与c的区别">1、C与C++的区别</h4>
<blockquote>
  <p><a href="https://www.cnblogs.com/ITziyuan/p/9487760.html">link</a>
C++是C的超集，也可以说C是C++的子集。一个不带参数的C函数原型必须把void写出来。而C++可以使用空参数列表。C++中<strong>new和delete</strong>是对内存分配的运算符，取代了C中的malloc和free。标准C++中的<strong>字符串类取代了</strong>C标准C函数库头文件中的<strong>字符数组处理函数（C中没有字符串类型）</strong>。C++中用来做控制态输入输出的<strong>iostream类库替代了标准C中的stdio</strong>函数库。C++中的<strong>try/catch/throw异常处理机制取代了标准C中的setjmp()和longjmp()函数</strong>。 在C++中还增加了<strong>bool型变量和wchar_t型变量</strong>。输入输出是使用语句scanf()和printf()来实现的，而C++中是使用<strong>cout/cin</strong>来实现的。在C++中，允许有相同的函数名（<strong>重载</strong>）。C++语言中，<strong>允许变量定义语句在程序中的任何地方</strong>，只要在是使用它之前就可以；而C语言中，必须要在函数开头部分。在C++中，<strong>引用</strong>是一个经常使用的概念。引用型变量是其他变量的一个别名，我们可以认为他们只是名字不相同，其他都是相同的。C++允许声明一个<strong>无名形参</strong>，以告诉编译器存在该参数int func(int x, int).C++函数的<strong>原型中可以声明一个或多个带有默认值的参数。</strong>
设计思想上：
C++是面向对象的语言，而C是面向过程的结构化编程语言
语法上：
C++具有封装、继承和多态三种特性
C++相比C，增加多许多类型安全的功能，比如强制类型转换、
C++支持范式编程，比如模板类、函数模板等</p>

</blockquote>

<h4 id="2new的数据能用free吗">2、new的数据能用free吗？</h4>
<blockquote>
  <p>不可以，new对应delete不可以张冠李戴。
malloc/free,new/delete必需配对使用。
malloc与free是c++、C语言的标准库函数，new、delete是c++的运算符。它们都可用于申请动态内存和释放内存。对于非内部数据类型的对象而言，光用malloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。因此c++语言需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。注意new/delete不是库函数。</p>
</blockquote>

<p>####3、C++中delete a和 delete[] a的区别 <a href="https://blog.csdn.net/snow_rain_1314/article/details/79916059">∞</a></p>
<blockquote>
  <p>如果ptr代表一个用new申请的内存返回的内存空间地址，即所谓的指针，那么：
delete ptr 代表用来释放内存，且只用来释放ptr指向的内存。
delete[] rg 用来释放rg指向的内存，！！<strong>还逐一调用数组中每个对象的destructor</strong>！！
对于像int/char/long/int*/struct等等简单数据类型，由于对象没有destructor，所以用delete 和delete [] 是一样的！但是如果是C++对象数组就不同了！
<strong>注意：</strong>不过不管使用delete还是delete[]那三个对象的在内存中都被删除，既存储位置都标记为可写，但是使用delete的时候只调用了p[0]的析构函数，而使用了delete[]则调用了3个myClass对象的析构函数。你一定会问，反正不管怎样都是把存储空间释放了，有什么区别？<strong>答：</strong>
关键在于调用析构函数上。此程序的类没有使用操作系统的系统资源（比如：Socket、File、Thread等），所以不会造成明显恶果。<strong>如果你的类使用了操作系统资源，单纯把类的对象从内存中删除是不妥当的，因为没有调用对象的析构函数会导致系统资源不被释放</strong>。</p>
</blockquote>

<h4 id="4new与malloc的区别">4、new与malloc的区别</h4>
<p><strong>new/delete</strong></p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="o">*</span><span class="n">pi</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">pi</span><span class="o">=</span><span class="k">new</span> <span class="nf">int</span><span class="p">();</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">pi</span><span class="o">=</span><span class="k">new</span> <span class="nf">int</span><span class="p">(</span><span class="mi">1024</span><span class="p">);</span>
<span class="k">delete</span> <span class="n">pi</span><span class="p">;</span>
<span class="n">pi</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
</code></pre></div></div>
<p><strong>malloc/free</strong></p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 函数原型</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">malloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">free</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">pointer</span><span class="p">);</span>
<span class="c1">// 使用</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="o">=</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>                   <span class="c1">//指向整型的指针p指向一个大小为100字节的内存的地址</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="o">=</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="mi">25</span><span class="o">*</span><span class="nf">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span> <span class="c1">//指向整型的指针p指向一个25个int整型空间的地址</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="o">=</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">pi</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Out of memory!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="n">free</span> <span class="p">(</span><span class="n">p</span><span class="p">);</span>
</code></pre></div></div>
<p>另外还有两个分配内存的函数：<strong>calloc和realloc</strong>，他们的原型如下：</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="o">*</span><span class="nf">calloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">num_elements</span><span class="p">,</span><span class="kt">size_t</span> <span class="n">element_size</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">realloc</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">tr</span> <span class="p">,</span> <span class="kt">size_t</span> <span class="n">new_size</span><span class="p">);</span>
</code></pre></div></div>
<p>　　malloc和calloc间的主要区别在于后者在返回指向内存的指针之前把它初始化为0。另一个区别是calloc的参数包括所需的元素的数量和每个元素的字节数。
　　realloc函数用于修改一个原先已经分配的内存块的大小。可以使一块内存扩大或缩小，如果扩大内存，则原来的内存块保持不变，在内存尾部增加新的内存块，切不进行初始化。如果缩小内存，则原来内存块从尾部进行删减。如果原先的内存块无法扩充，则新开辟一块内存，并复制原先的内存的内容，原先内存块失效无法再进行访问。</p>

<p><strong>区别</strong></p>
<blockquote>
  <ul>
    <li>a.属性
new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持c。</li>
    <li>b.参数
使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。</li>
    <li>c.返回类型
new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。</li>
    <li>d. 分配失败
new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。</li>
    <li>e.自定义类型
new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。
malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。</li>
    <li>f.重载
C++允许重载new/delete操作符，特别的，布局new的就不需要为对象分配内存，而是指定了一个地址作为内存起始区域，new在这段内存上为对象调用构造函数完成初始化工作，并返回此地址。而malloc不允许重载。</li>
    <li>g.内存区域
new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。自由存储区不等于堆，如上所述，布局new就可以不位于堆中。</li>
  </ul>
</blockquote>

<h4 id="5拷贝构造函数-">5、拷贝构造函数 <a href="https://www.cnblogs.com/alantu2018/p/8459250.html">∞</a></h4>
<blockquote>
  <p>①拷贝有两种：深拷贝，浅拷贝。
      当出现类的等号赋值时，会调用拷贝函数，在未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷贝是可行的。但当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致指针悬挂现象。所以，这时，必须采用深拷贝。<strong>深拷贝与浅拷贝的区别就在于深拷贝会在堆内存中另外申请空间来储存数据，从而也就解决了指针悬挂的问题。简而言之，当数据成员中有指针时，必须要用深拷贝</strong>
② 为什么拷贝构造函数必须是引用传递，不能是值传递？
简单的回答是为了防止递归引用。
具体一些可以这么讲：当 一个对象需要以值方式传递时，编译器会生成代码调用它的拷贝构造函数以生成一个复本。如果类A的拷贝构造函数是以值方式传递一个类A对象作为参数的话，当 需要调用类A的拷贝构造函数时，需要以值方式传进一个A的对象作为实参； 而以值方式传递需要调用类A的拷贝构造函数；结果就是调用类A的拷贝构造函数导 致又一次调用类A的拷贝构造函数，这就是一个无限递归。</p>
</blockquote>

<h4 id="6main函数">6、main函数</h4>
<blockquote>
  <p>C++的main函数可以没有输入参数，也可以有输入参数，而且只能有两个参数，习惯上coding如下：
<code class="highlighter-rouge">int main(int argc, char* argv[]) 或者 int main(int argc, char** argv)</code>
其中，argc = argument count ：表示传入main函数的数组元素个数，为int类型，而 argv = argument vector ：表示传入main函数的指针数组，为char**类型。第一个数组元素argv[0]是程序名称，并且包含程序所在的完整路径。argc至少为1，即argv数组至少包含程序名。
由于main函数不能被其他函数调用，因此不可能在程序内部取得实际值。main函数的参数值是从操作系统命令行上获取的。在window系统中，假如编译链接成的可执行文件为my_project.exe，则在命令提示符中，键入如下命令(可执行文件 参数 参数 参数 …)：
<code class="highlighter-rouge">my_project.exe jisongxie 1996</code>
将会传递三个参数给main函数，第一个argv[0]是前面提到的文件名，第二个argv[1]是”jisongxie”，第三个argv[2]是“1996”。</p>
</blockquote>

<h4 id="7重载重写覆盖隐藏">7、<a href="https://www.cnblogs.com/zhangjxblog/p/8723291.html"><strong>重载、重写（覆盖）、隐藏</strong></a></h4>
<blockquote>
  <p><strong>重载和重写的区别：</strong>
（1）范围区别：重写和被重写的函数在不同的类中，重载和被重载的函数在同一类中。
（2）参数区别：重写与被重写的函数参数列表一定相同，重载和被重载的函数参数列表一定不同。
（3）virtual的区别：重写的基类必须要有virtual修饰，重载函数和被重载函数可以被virtual修饰，也可以没有。
<strong>隐藏和重写，重载的区别：</strong>
（1）与重载范围不同：隐藏函数和被隐藏函数在不同类中。
（2）参数的区别：隐藏函数和被隐藏函数参数列表可以相同，也可以不同，但函数名一定同；当参数不同时，无论基类中的函数是否被virtual修饰，基类函数都是被隐藏，而不是被重写。</p>
</blockquote>

<h4 id="8继承和组合">8、继承和组合</h4>
<blockquote>
  <p>1）什么是继承
A继承B，说明A是B的一种，并且B的所有行为对A都有意义
eg:A=WOMAN B=HUMAN
A=鸵鸟 B=鸟 （不行），因为鸟会飞，但是鸵鸟不会。
2）什么是组合
若在逻辑上A是B的“一部分”(a part of)，则不允许B从A派生，而是要用A和其它东西组合出B。
例如眼(Eye)、鼻(Nose)、口(Mouth)、耳(Ear)是头(Head)的一部分，所以类Head应该由类Eye、Nose、Mouth、Ear组合而成，不是派生而成
<img src="./2019-10-30-C++review-png/1571231560539.png" alt="Alt text" /></p>
</blockquote>

<h4 id="9const与define区别">9、const与define区别</h4>
<blockquote>
  <p>角度1： 就定义常量说的话：  const 定义的常数是变量 也带类型， #define 定义的只是个常数 不带类型。
角度2： 就起作用的阶段而言： define是在编译的预处理阶段起作用，而const是在 编译、运行的时候起作用。
角度3： 就起作用的方式而言： define只是简单的字符串替换，没有类型检查。而const有对应的数据类型，是要进行判断的，可以避免一些低级的错误。 正因为define只是简单的字符串替换会导致边界效应，具体举例可以参考下面代码：</p>
  <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define N 2+3 //我们预想的N值是5，我们这样使用N
</span><span class="kt">double</span> <span class="n">a</span> <span class="o">=</span> <span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>  <span class="c1">//我们预想的a的值是2.5，可实际上a的值是3</span>
</code></pre></div>  </div>
  <p>角度4： 就空间占用而言： 例如：</p>
  <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define PI 3.14     //预处理后 占用代码段空间
</span><span class="k">const</span> <span class="kt">float</span> <span class="n">PI</span><span class="o">=</span><span class="mf">3.14</span><span class="p">;</span>    <span class="c1">//本质上还是一个 float，占用数据段空间12</span>
</code></pre></div>  </div>
  <p>角度5： 从代码调试的方便程度而言： const常量可以进行调试的，define是不能进行调试的，因为在预编译阶段就已经替换掉了.
角度6： 从是否可以再定义的角度而言： const不足的地方，是与生俱来的，const不能重定义，而#define可以通过#undef取消某个符号的定义，再重新定义。
角度7： 从某些特殊功能而言： define可以用来防止头文件重复引用，而const不能</p>
</blockquote>

<h4 id="10虚函数与纯虚函数">10、虚函数与纯虚函数</h4>
<p><strong>虚函数</strong></p>
<blockquote>
  <p>所谓<strong>虚函数</strong>，就是在基类声明函数时虚拟的，并不是实际存在的函数，然后在派生类中才正式定义此函数。在程序运行期间，用指针指向某一派生类对象，这样就能调用指针指向的派生类对象中的函数，而不会调用其他派生类中的函数。虚函数的作用是允许在派生类中重新定义与基类同名的函数，并且可以通过基类指针或引用来访问基类和派生类中的同名函数。
<a href="https://www.cnblogs.com/hust-ghtao/p/3512461.html">参考1</a> | <a href="https://www.cnblogs.com/forcheryl/p/4705848.html">参考2</a> | <a href="https://blog.csdn.net/qq_40086556/article/details/81778064">参考3</a>
<strong>虚函数的实现</strong>
C++中虚函数使用虚函数表和虚函数表指针实现，虚函数表是一个类的虚函数的地址表，用于索引类本身以及父类的虚函数的地址，假如子类重写了父类的虚函数，则对应在虚函数表中会把对应的虚函数替换为子类的函数的地址（子类中可以不是虚函数，但是必须同名）；虚函数表指针存在于每个对象中（通常出于效率考虑，会放在对象的开始地址处），它指向对象所在类的虚函数表的地址；在多继承环境下，会存在多个虚函数表指针，分别指向对应不同基类的虚函数表。虚函数表是每个（有虚函数的）类对应一个。虚函数表指针是每个对象对应一个。
<strong>虚函数表存放在全局数据区（静态区）原因：</strong>
1.虚函数表是全局共享的元素,即全局仅有一个.
2.虚函数表类似一个数组,类对象中存储vptr指针,指向虚函数表.即虚函数表不是函数,不是程序代码,不肯能存储在代码段.
3.虚函数表存储虚函数的地址,即虚函数表的元素是指向类成员函数的指针,而类中虚函数的个数在编译时期可以确定,即虚函数表的大小可以确定,即大小是在编译时期确定的,不必动态分配内存空间存储虚函数表,所以不再堆中.
根据以上特征,虚函数表类似于类中静态成员变量.静态成员变量也是全局共享,大小确定.
所以我推测虚函数表和静态成员变量一样,存放在全局数据区.</p>
</blockquote>

<blockquote>
  <p><strong>内联函数、构造函数、静态成员函数可以是虚函数吗？</strong>
都不可以。
内联函数（inline）需要在编译阶段展开（在编译时就已经确定了），而虚函数是运行时动态绑定的，编译时无法展开，因此是矛盾的；
构造函数在进行调用时还不存在父类和子类的概念，父类只会调用父类的构造函数，子类调用子类的，因此不存在动态绑定的概念（先有父类才能有子类，构造父类的时候子类还不存在，子类都还没有怎么可能在父类里动态调用子类）；
静态成员函数（static）是以类为单位的函数，与具体对象无关，虚函数是与对象动态绑定的，因此是两个矛盾的概念</p>
</blockquote>

<p><strong><a href="https://www.runoob.com/w3cnote/cpp-virtual-functions.html">纯虚函数</a></strong></p>
<blockquote>
  <p>纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加 =0:。只要有纯虚函数的类就是抽象类，不能实例化对象。
<code class="highlighter-rouge">virtual void funtion1()=0</code></p>
</blockquote>

<p><strong>为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数</strong></p>
<blockquote>
  <p>1.析构函数不一定必须是虚函数，是否为虚函数取决于该类的使用，一般该类为基类产生继承和多态时，才会是虚函数，单独使用可以不是虚函数。之所以在继承和多态时设计为虚函数是因为当new派生类并且用基类指针指向这个派生类，在销毁基类指针时只会调用基类的析构函数，不会调用派生类的析构函数，因为基类无法操作派生类中非继承的成员，这样就造成派生类只new无法delete造成内存泄露。（在实现多态时，当用基类操作派生类，在析构时防止只析构基类而不析构派生类的状况发生。）
2.默认不是虚析构函数是因为如果析构函数为虚函数就需要编译器在类中增加虚函数表来实现虚函数机制，这样所需内存空间就更大了，因此没有必要默认为虚析构函数。</p>
</blockquote>

<p><strong>构造函数可以是虚函数吗？</strong></p>
<blockquote>
  <p>可以，但是没必要。
1、虚函数调用是在部分信息下完成工作的机制，允许我们只知道接口而不知道对象的确切类型。 要创建一个对象，你需要知道对象的完整信息。 特别是，你需要知道你想要创建的确切类型。 因此，构造函数不应该被定义为虚函数。
从C++之父Bjarne的回答我们应该知道C++为什么不支持构造函数是虚函数了，简单讲就是没有意义。虚函数的作用在于通过子类的指针或引用来调用父类的那个成员函数。而构造函数是在创建对象时自己主动调用的，不可能通过子类的指针或者引用去调用。
2、虚函数相应一个指向vtable虚函数表的指针，但是这个指向vtable的指针事实上是存储在对象的内存空间的。假设构造函数是虚的，就须要通过 vtable来调用，但是对象还没有实例化，也就是内存空间还没有，怎么找vtable呢？所以构造函数不能是虚函数。</p>
</blockquote>

<h4 id="11继承">11、继承</h4>
<blockquote>
  <p>1、创建派生类对象时程序调用派生类构造函数，然后在初始化列表部分调用基类构造函数初始化继承的数据成员，而派生类构造函数主要初始化新增的数据成员。派生类总是调用一个基类构造函数。可以使用初始化列表语法指明要使用的基类构造函数，否则将使用默认的基类构造函数。派生类对象过期时，程序将先调用派生类析构函数，在函数体执行完之后调用基类析构函数。（可以看到，继承的数据成员生命周期长， 新增的数据成员生命周期短。）
<img src="./2019-10-30-C++review-png/1561865604128.png" alt="Alt text" /></p>
</blockquote>

<h4 id="12多态">12、多态</h4>
<blockquote>
  <p>简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。
在面向对象方法中一般是这样表述多态性的：向不同的对象发送同一个消息，不同的对象在接收时会产生不同的行为。也就是说，每个对象可以用自己的方式去响应共同的消息，所谓消息，就是调用函数，不同的行为就是指不同的实现，即执行不同的函数。在C++中，多态性表现形式之一是：具有不同功能的函数可以用同一个函数名，这样就可以实现用一个函数名调用不同内容的函数。</p>
</blockquote>

<p><strong>静态多态和动态多态</strong></p>
<blockquote>
  <p><strong>静态多态性</strong>是通过函数重载实现。由函数重载和运算符重载（运算符重载实质上也是函数重载）形成的多态性属于静态多态性，要求程序在编译时就知道函数调用的全部信息，因此，在程序编译时系统就能决定要调用的是哪个函数。静态多态性的函数调用速度快、效率高，但是缺乏灵活性，在程序运行之前就已经决定了执行的函数和方法。
 <strong>动态多态性</strong>是通过虚函数实现的。特点是：不在编译时确定调用的哪个函数，而是在程序运行过程中动态地确定操作所针对的对象。</p>
</blockquote>

<h4 id="13指针和引用的区别">13、指针和引用的区别</h4>
<blockquote>
  <p><strong>可修改区别 **指针在运行时可以改变其所指向的值，而引用一旦和某个对象绑定后就不再改变。
**内存分配 **程序为指针变量分配内存区域，而不为引用分配内存区域，引用只是一个别名。
**不存在指向空值的引用</strong>使用引用的代码效率比使用指针要高。 
可以有const指针，但是没有const引用
指针可以有多级，但是引用只能是一级（int **p；合法 而 int &amp;&amp;a是不合法的）
”sizeof引用”得到的是所指向的变量(对象)的大小，而”sizeof指针”得到的是指针本身的大小
指针和引用的自增(++)运算意义不一样</p>
</blockquote>

<p><strong>引用的规则：</strong></p>
<blockquote>
  <p>（1）引用被创建的同时必须被初始化（指针则可以在任何时候被初始化）。
（2）不能有 NULL 引用，引用必须与合法的存储单元关联（指针则可以是 NULL）。
（3）一旦引用被初始化，就不能改变引用的关系（指针则可以随时改变所指的对象）。</p>
</blockquote>

<h4 id="14typedef-typename-作用">14、typedef typename 作用</h4>

<blockquote>
  <p>**typedef: **1) 为各种数据类型定义新名字; 2) 用来定义函数指针。
**typename: **
1) 在模板定义中，表明其后的模板参数为类型参数<code class="highlighter-rouge">template&lt;typename T&gt;</code>;
2) 在模板中用于表明内嵌依赖类型名（Nested Dependent Type Name）</p>

  <p><code class="highlighter-rouge">typedef typename std::vector&lt;T&gt;::size_type size_type;</code>
为什么要加上typename关键字？
回答：实际上，模板类型在实例化之前，编译器并不知道vector<T>::size_type是什么东西，事实上一共有三种可能：
	- 静态数据成员
	- 静态成员函数
	- 嵌套类型
typedef创建了存在类型的别名，而typename告诉编译器std::vector<T>::size_type是一个类型而不是一个成员。</T></T></p>
</blockquote>

<h4 id="15c内存管理">15、<a href="https://blog.csdn.net/Lao_tan/article/details/81292676">c++内存管理</a></h4>
<p><strong>内存分配方式</strong>
<img src="./2019-10-30-C++review-png/1561894534593.png" alt="Alt text" />
（说明：网页中把堆和自由存储区搞混了）
<strong>自由存储区和堆</strong></p>
<blockquote>
  <p>从技术上来说，堆（heap）是C语言和操作系统的术语。堆是操作系统所维护的一块特殊内存，它提供了动态分配的功能，当运行程序调用malloc()时就会从中分配，稍后调用free可把内存交还。而自由存储是C++中通过new和delete动态分配和释放对象的抽象概念，通过new来申请的内存区域可称为自由存储区。基本上，所有的C++编译器默认使用堆来实现自由存储，也即是缺省的全局运算符new和delete也许会按照malloc和free的方式来被实现，这时藉由new运算符分配的对象，说它在堆上也对，说它在自由存储区上也正确。但程序员也可以通过重载操作符，改用其他内存来实现自由存储，例如全局变量做的对象池，这时自由存储区就区别于堆了。我们所需要记住的就是：
<strong>堆是操作系统维护的一块内存，而自由存储是C++中通过new与delete动态分配和释放对象的抽象概念。堆与自由存储区并不等价。</strong></p>
</blockquote>

<p><strong>内存泄漏</strong></p>
<blockquote>
  <p>一般我们常说的内存泄漏是指堆内存的泄漏。堆内存是指程序从堆中分配的，大小任意的，使用完之后必须显示释放的内存。应用程序一般使用malloc，new等函数从堆中分到一块内存，使用完之后，程序必须负责相应的调用free或delete释放该内存块，否则这块内存就不能再次使用，这就是内存泄漏。程序在函数入口处分配内存，在出口处释放内存，但是如果函数中有一个语句可以使函数在中途任何地方退出，那么这个函数就会发生内存泄漏。</p>
</blockquote>

<p><strong>栈和堆的区别</strong>
    &gt;  一、程序的内存分配方式不同。
      二、申请和响应不同：
     1、申请方式：stack由系统自动分配，heap需要程序员自己申请，C中用函数malloc分配空间，用free释放，C++用new分配，用delete释放。
     2、申请后系统的响应：
      栈：只要栈的剩余空间大于所申请的空间，体统将为程序提供内存，否则将报异常提示栈溢出。
      堆：首先应该知道操作系统有一个记录内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请的空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样代码中的delete或free语句就能够正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会将多余的那部分重新放入空闲链表中。
     三、 申请的大小限制不同：
     栈：在windows下，栈是向低地址扩展的数据结构，是一块连续的内存区域，栈顶的地址和栈的最大容量是系统预先规定好的，能从栈获得的空间较小。
    堆：堆是向高地址扩展的数据结构，是不连续的内存区域，这是由于系统是由链表在存储空闲内存地址，自然堆就是不连续的内存区域，且链表的遍历也是从低地址向高地址遍历的，堆得大小受限于计算机系统的有效虚拟内存空间，由此空间，堆获得的空间比较灵活，也比较大。
     四、申请的效率不同：
     栈：栈由系统自动分配，速度快，但是程序员无法控制。
     堆：堆是有程序员自己分配，速度较慢，容易产生碎片，不过用起来方便。
     五、堆和栈的存储内容不同：
     栈：在函数调用时，第一个进栈的是主函数中函数调用后的下一条指令的地址，然后是函数的各个参数，在大多数的C编译器中，参数是从右往左入栈的，当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令。
     堆：一般是在堆得头部用一个字节存放堆得大小，具体内容由程序员安排。</p>

<h4 id="16各类函数的比较">16、各类函数的比较</h4>
<p><strong>虚函数和普通函数的区别</strong></p>
<blockquote>
  <p>类中的虚函数是动态生成的，由虚函数表的指向进行访问，不为类的对象分配内存，就没有虚函数表就无法访问。
类中的普通函数静态生成，不为类的对象分配内存也可访问。</p>
</blockquote>

<p><strong>静态成员函数与普通成员函数的区别：</strong></p>
<blockquote>
  <p>静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。
普通成员函数有 this 指针，可以访问类中的任意成员；而静态成员函数没有 this 指针。</p>
</blockquote>

<p><strong>构造函数的作用</strong> <a href="https://www.cnblogs.com/yetuweiba/p/4231870.html">link</a></p>
<blockquote>
  <p>构造函数的作用：初始化对象的数据成员。
该类对象被创建时，编译系统为对象分配内存空间，并自动调用该构造函数-&gt;由构造函数完成成员的初始化工作。
在我们没有对象指定构造函数的时候，编译器会为我们生成默认构造函数，拷贝构造函数，默认析构函数</p>
</blockquote>

<p><strong>析构函数的作用</strong></p>
<blockquote>
  <p>析构函数主要作用就是释放资源,避免内存泄漏。
1、析构函数(destructor) 与构造函数相反，当对象结束其生命周期时（例如对象所在的函数已调用完毕），系统自动执行析构函数。析构函数往往用来做“清理善后” 的工作（例如在建立对象时用new开辟了一片内存空间。
2、析构函数如果我们不写的话，C++ 会帮我们自动的合成一个，就是说：C++ 会自动的帮我们写一个析构函数。很多时候，自动生成的析构函数可以很好的工作，但是一些重要的事迹，就必须我们自己去写析构函数。</p>
</blockquote>

<h4 id="17i与i">17、<a href="https://blog.csdn.net/Mormont/article/details/53131526">i++与++i</a></h4>
<blockquote>
  <p>i++    是先使用，再自加（其自加是在遇到结束标志时才会进行）
即a = i;i=i+1;
++i    是先自加，再使用
即 i=i+1； a= i;</p>
</blockquote>

<blockquote>
  <p><strong>i++与++i的效率</strong>
是内建数据类型时，它们的效率差别不大（去除编译器优化的影响）。所以在这种情况下我们大可不必关心。
自定义数据类型（主要是指类）时，此时我们不需要再做很多汇编代码的分析了，因为前缀式（++i）可以返回对象的引用，而后缀式（i++）必须产生一个临时对象保存更改前对象的值并返回(实现过自定义类型++运算符定义的就知道)，所以导致在大对象的时候产生了较大的复制开销，引起效率降低，因此处理使用者自定义类型（注意不是指内建类型）的时候，应该尽可能的使用前缀式地增/递减，因为他天生体质较佳。</p>
</blockquote>

<h4 id="18-函数指针与指针函数辨别">18、 函数指针与指针函数辨别</h4>
<blockquote>
  <p><strong>函数指针</strong>是一种特殊的 <strong>指针</strong>,它指向函数的入口。
例如int (*add)(int, int);定义了一个函数指针add，用于指向返回值为int，并且有两个int参数的函数</p>
</blockquote>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">addfunc</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">add</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="n">addfunc</span><span class="p">;</span>
        <span class="c1">//两种方法都可以</span>
        <span class="c1">//int (*add)(int, int) = &amp;addfunc;</span>

        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">add</span><span class="p">)(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
        <span class="c1">//两种方法都可以，建议使用第一种</span>
        <span class="c1">//int result = add(1, 2);</span>
<span class="p">}</span>
</code></pre></div></div>
<p><strong>指针函数</strong>是一种返回值为指针的 <strong>函数</strong>。
例如A *createA();声明了一个返回值为指向A类型的指针的，参数列表为空的函数
<code class="highlighter-rouge">void (* set_malloc_handler(void (*f)()))()</code>
我们把例子从里往外看</p>
<blockquote>
  <p><code class="highlighter-rouge">void (*f)()</code>是一个函数指针，它用于指向一个返回值为void，无参数列表的函数
<code class="highlighter-rouge">*set_malloc_handler(void (*f)())</code>这是一个指针函数，返回值为指针，它有一个参数，参数为一个函数指针（返回值为void,无参数列表的函数）
<code class="highlighter-rouge">void (* set_malloc_handler(void (*f)()))()</code>这是一个指针函数，返回值为函数指针（返回值为void,无参数列表的一个函数），它有一个参数，参数为一个函数指针。</p>
</blockquote>

<h4 id="18智能指针">18、<a href="https://www.cnblogs.com/KillerAery/p/9096558.html">智能指针</a></h4>
<blockquote>
  <p>智能指针实质是一个对象，行为表现的却像一个指针
<code class="highlighter-rouge">auto_ptr</code> 不要使用
<code class="highlighter-rouge">unique_ptr</code> 独占资源所有权，不允许赋值</p>
  <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Monster</span><span class="o">&gt;</span> <span class="n">monster1</span><span class="p">(</span><span class="k">new</span> <span class="nf">Monster</span><span class="p">());</span><span class="c1">//monster1 指向 一个怪物</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Monster</span><span class="o">&gt;</span> <span class="n">monster2</span> <span class="o">=</span> <span class="n">monster1</span><span class="p">;</span><span class="c1">//Error!编译期出错，不允许复制指针指向同一个资源。</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Monster</span><span class="o">&gt;</span> <span class="n">monster3</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">monster1</span><span class="p">);</span><span class="c1">//转移所有权给monster3.</span>
<span class="n">monster1</span><span class="o">-&gt;</span><span class="n">doSomething</span><span class="p">();</span><span class="c1">//Oops!monster1指向nullptr，运行期崩溃</span>
</code></pre></div>  </div>
</blockquote>

<p><code class="highlighter-rouge">shared_ptr</code> 强引用，允许多个指向同一资源，引用计数</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">runGame</span><span class="p">(){</span>
<span class="err">　　</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Monster</span><span class="o">&gt;</span> <span class="n">monster1</span><span class="p">(</span><span class="k">new</span> <span class="n">Monster</span><span class="p">());</span><span class="err">　　　</span><span class="c1">//计数加到1</span>

<span class="err">　　</span><span class="k">do</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Monster</span><span class="o">&gt;</span> <span class="n">monster2</span> <span class="o">=</span> <span class="n">monster1</span><span class="p">;</span><span class="err">　　　　</span><span class="c1">//计数加到2</span>
<span class="err">　　</span><span class="p">}</span><span class="k">while</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="err">　　　　　　　　　　</span>
<span class="err">　　</span><span class="c1">//该栈退出后，计数减为1，monster1指向的堆对象仍存在</span>

<span class="err">　　</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Monster</span><span class="o">&gt;</span> <span class="n">monster3</span> <span class="o">=</span> <span class="n">monster1</span><span class="p">;</span><span class="err">　　　　　　</span><span class="c1">//计数加到2</span>
<span class="p">}</span>
<span class="c1">//该栈退出后，shared_ptr都释放了，计数减为0，它们指向的堆对象也能跟着释放.</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">weak_ptr</code>  弱引用，只能访问，可以解决悬空指针，循环引用问题</p>

<p><strong>针对空悬指针问题：</strong></p>
<blockquote>
  <p>空悬指针问题是指：无法知道指针指向的堆内存是否已经释放。
得益于引入的<code class="highlighter-rouge">weak_count,weak_ptr</code>指针可以使计数区域的生命周期受weak_ptr控制，
从而能使<code class="highlighter-rouge">weak_ptr</code>获取 被管理资源的shared计数，从而判断被管理对象是否已被释放。（可以实时动态地知道指向的对象是否被释放,从而有效解决空悬指针问题）
它的成员函数expired()就是判断指向的对象是否存活。</p>
</blockquote>

<p><strong>针对循环引用问题：</strong>
问题：</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Monster</span><span class="p">{</span>
<span class="err">　　</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Monster</span><span class="o">&gt;</span> <span class="n">m_father</span><span class="p">;</span>
<span class="err">　　</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Monster</span><span class="o">&gt;</span> <span class="n">m_son</span><span class="p">;</span>
<span class="nl">public:</span>
<span class="err">　　</span><span class="kt">void</span> <span class="n">setFather</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Monster</span><span class="o">&gt;&amp;</span> <span class="n">father</span><span class="p">);</span><span class="c1">//实现细节懒得写了</span>
<span class="err">　　</span><span class="kt">void</span> <span class="n">setSon</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Monster</span><span class="o">&gt;&amp;</span> <span class="n">son</span><span class="p">);</span><span class="err">　　　</span> <span class="c1">//懒</span>
<span class="err">　　</span><span class="o">~</span><span class="n">Monster</span><span class="p">(){</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"A monster die!"</span><span class="p">;}</span><span class="err">　　　　</span><span class="c1">//析构时发出死亡的悲鸣</span>
<span class="p">};</span>
<span class="c1">// 执行</span>
<span class="kt">void</span> <span class="nf">runGame</span><span class="p">(){</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Monster</span><span class="o">&gt;</span> <span class="n">father</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Monster</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Monster</span><span class="o">&gt;</span> <span class="n">son</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Monster</span><span class="p">();</span>
    <span class="n">father</span><span class="o">-&gt;</span><span class="n">setSon</span><span class="p">(</span><span class="n">son</span><span class="p">);</span>
    <span class="n">son</span><span class="o">-&gt;</span><span class="n">setFather</span><span class="p">(</span><span class="n">father</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<blockquote>
  <p>模拟执行
开始:
father,son指向的堆对象 shared计数都是为2
son智能指针退出栈：
son指向的堆对象 计数减为1，father指向的堆对象 计数仍为2。
father智能指针退出栈:
father指向的堆对象 计数减为1 , son指向的堆对象 计数仍为1。
函数结束：所有计数都没有变0，也就是说中途没有释放任何堆对象。</p>
</blockquote>

<p>解决：</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Monster</span><span class="p">{</span>
<span class="err">　　</span><span class="c1">//尽管父子可以互相访问，但是彼此都是独立的个体，无论是谁都不应该拥有另一个人的所有权。</span>
<span class="err">　　</span><span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">Monster</span><span class="o">&gt;</span> <span class="n">m_father</span><span class="p">;</span><span class="err">　　　　</span><span class="c1">//所以都把shared_ptr换成了weak_ptr</span>
<span class="err">　　</span><span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">Monster</span><span class="o">&gt;</span> <span class="n">m_son</span><span class="p">;</span><span class="err">　　　　　　</span><span class="c1">//同上</span>
<span class="nl">public:</span>
<span class="err">　　</span><span class="kt">void</span> <span class="n">setFather</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Monster</span><span class="o">&gt;&amp;</span> <span class="n">father</span><span class="p">);</span> <span class="c1">//实现细节懒得写了</span>
<span class="err">　　</span><span class="kt">void</span> <span class="n">setSon</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Monster</span><span class="o">&gt;&amp;</span> <span class="n">son</span><span class="p">);</span><span class="err">　　　　</span><span class="c1">//懒</span>
<span class="err">　　</span><span class="o">~</span><span class="n">Monster</span><span class="p">(){</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"A monster die!"</span><span class="p">;}</span><span class="err">　　　　</span> <span class="c1">//析构时发出死亡的悲鸣</span>
<span class="p">};</span>
<span class="kt">void</span> <span class="nf">runGame</span><span class="p">(){</span>
<span class="err">　　</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Monster</span><span class="o">&gt;</span> <span class="n">father</span><span class="p">(</span><span class="k">new</span> <span class="n">Monster</span><span class="p">());</span>
<span class="err">　　</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Monster</span><span class="o">&gt;</span> <span class="n">son</span><span class="p">(</span><span class="k">new</span> <span class="n">Monster</span><span class="p">());</span>
<span class="err">　　</span><span class="n">father</span><span class="o">-&gt;</span><span class="n">setSon</span><span class="p">(</span><span class="n">son</span><span class="p">);</span>
<span class="err">　　</span><span class="n">son</span><span class="o">-&gt;</span><span class="n">setFather</span><span class="p">(</span><span class="n">father</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<blockquote>
  <p>模拟执行：
father指向的堆对象 shared计数为1,weak计数为1
son指向的堆对象 shared计数为1,weak计数为1
son智能指针退出栈：
son指向的堆对象 shared计数减为0,weak计数为1,释放son的堆对象,发出第一个死亡的悲鸣
father指向的堆对象 shared计数为1,weak计数减为0;
father智能指针退出栈:
father指向的堆对象 shared计数减为0,weak计数为0;释放father的堆对象和father的计数区域,发出第二个死亡的悲鸣。
son指向的堆对象 shared计数为0,weak计数减为0;释放son的计数区域。
函数结束，释放行为正确。</p>
</blockquote>

<h4 id="19-const-static">19、 const, static</h4>
<p><strong>const</strong>
	&gt; 如果const位于星号左侧，则用来修饰指针所指的变量，即指针指向内容为常理，如情况一、二；如果位于星号右侧，则修饰指针本身，即指针为常量，如情况三。情况四是指针和内容都为常量。
	const成员函数，即只读函数，这些函数不改变类的数据成员。例如 int Getdata ( ) const;
<img src="./2019-10-30-C++review-png/1551798676888.png" alt="Alt text" /></p>

<blockquote>
  <p><strong>主要作用：</strong>
修饰变量或对象，说明该变量或对象不能被改变
修饰指针，分为指向常量的指针（const在星号左边，不能用指针改值，属于底层const）和常指针（const在*号右边，能用指针改值，属于顶层const）
修饰引用，常用于形参，既避免了拷贝，又避免了函数对值的修改
修饰成员函数，说明该成员函数内不能修改成员变量。此时可以用于区分重载（常对象调用常成员函数）
修饰成员变量，此时只能在构造函数初始化参数列表初始化</p>
</blockquote>

<blockquote>
  <p><strong>const 修饰成员函数</strong>
函数前面和后面 使用const 的作用：</p>
  <ul>
    <li>前面使用const 表示返回值为const</li>
    <li>后面加 const表示函数不可以修改class的成员</li>
  </ul>
</blockquote>

<p><strong>C++为什么不可以同时用const和static修饰成员函数？</strong>
C++编译器在实现const的成员函数的时候为了确保该函数不能修改类的实例的状态，会在函数中添加一个隐式的参数const this*。但当一个成员为static的时候，该函数是没有this指针的。也就是说此时const的用法和static是冲突的。</p>

<h4 id="static-"><a href="https://www.cnblogs.com/songdanzju/p/7422380.html">static </a></h4>
<blockquote>
  <p><strong>主要作用：</strong></p>
  <ol>
    <li>修饰普通变量，使变量存储在静态区。在main函数前就分配了空间。有初始值就初始化，没有就默认初始化</li>
    <li>修饰普通函数，防止多人开发时函数名相同</li>
    <li>修饰成员变量，使所有该类的对象共享这一份复制，在实现文件中初始化。不需要生成对象就能访问该成员。class::m_val</li>
    <li>修饰成员函数，此时static成员函数没有this指针，故只能访问static成员变量。不需要生成对象就能使用该函数。class::m_func</li>
    <li>函数体内的static变量作用范围仅为该函数体，不同于auto变量，该变量的内存只被分配一次。在下一次调用该函数时依然维持上一次的值。</li>
  </ol>
</blockquote>

<h4 id="20-c-stl">20、 C++ STL</h4>

<p><strong>① vector</strong></p>
<blockquote>
  <p>vector是我们用到最多的数据结构，其底层数据结构是数组，由于数组的特点，vector也具有以下特性：
1、O(1)时间的快速访问；
2、顺序存储，所以插入到非尾结点位置所需时间复杂度为O(n)，删除也一样；
3、扩容规则：
当我们新建一个vector的时候，会首先分配给他一片连续的内存空间，如std::vector<int> vec，当通过push_back向其中增加元素时，如果初始分配空间已满，就会引起vector扩容，其扩容规则在gcc下以2倍方式完成：
首先重新申请一个2倍大的内存空间；
然后将原空间的内容拷贝过来；
最后将原空间内容进行释放，将内存交还给操作系统；</int></p>
</blockquote>

<p><strong>② map &amp; multimap &amp; unordered_map &amp; unordered_multimap</strong></p>
<blockquote>
  <p><strong>map与multimap底层数据结构</strong>
map与multimap是STL中的关联容器、提供一对一key-value的数据处理能力； map与multimap的区别在于，multimap允许关键字重复，而map不允许重复。
这两个关联容器的底层数据结构均为红黑树，关于红黑树的理解可以参考教你透彻了解红黑树一文。
根据红黑树的原理，map与multimap可以实现O(lgn)的查找，插入和删除。</p>
</blockquote>

<blockquote>
  <p><strong>unordered_map 与unordered_multimap底层数据结构</strong>
unordered_map与unordered_multimap 对比2.1中的两种map在于其2.1中的两个容器实现了以key为序排列，也就是说map与multimap为有序的。
而unordered_map与unordered_multimap中key为无序排列，其底层实现为hash table，因此其查找时间复杂度理论上达到了O(n)，之所以说理论上是因为在理想无碰撞的情况下，而真实情况未必如此。</p>
</blockquote>

<p><strong>③ set &amp; multiset &amp; unordered_set &amp; unordered_multiset</strong></p>
<blockquote>
  <p>以上四种容器也都是关联容器，set系与map系的区别在于map中存储的是<key-value>，而set可以理解为关键字即值，即只保存关键字的容器。
**set &amp; multiset底层数据结构**
set与multiset有序存储元素，这两种容器的底层实现与map一样都是红黑树，所以能实现O(lgn)的查找，插入，删除操作。
set与multiset的区别在于是否允许重复；
**unordered_set &amp; unordered_multiset**
与unordered_map &amp; unordered_multimap相同，其底层实现为hash table；</key-value></p>
</blockquote>

<p><strong>④priority_queue</strong></p>
<blockquote>
  <p>优先级队列相当于一个有权值的单向队列queue，在这个队列中，所有元素是按照优先级排列的。
priority_queue根据堆的处理规则来调整元素之间的位置，关于堆的原理，可以参考堆；
根据堆的特性，优先级队列实现了取出最大最小元素时间复杂度为O(1),对于插入和删除，其最坏情况为O(lgn)。</p>
  <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">priority_queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">less</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">max</span><span class="p">;</span>
<span class="n">priority_queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">greater</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">min</span><span class="p">;</span>
</code></pre></div>  </div>
</blockquote>

<p><strong>⑤其他数据结构</strong></p>
<blockquote>
  <p>list的底层数据结构为双向链表，特点是支持快速的增删。
queue为单向队列，为先入先出原则。
deque为双向队列，其对比queue可以实现在头尾两端高效的插入和删除操作</p>
</blockquote>

<h4 id="21c为什么偏底层一点link">21、C为什么偏底层一点<a href="http://www.360doc.com/content/18/0214/19/37805727_729986561.shtml">link</a></h4>
<p><img src="./2019-10-30-C++review-png/1571277106311.png" alt="Alt text" /></p>

<h4 id="22递归无限执行时堆和栈是怎么溢出的">22、递归无限执行时，堆和栈是怎么溢出的</h4>
<blockquote>
  <p>在函数调用中，函数返回，就会进行出栈操作。如果递归次数很大，不断的进栈，不出栈，就会出现栈溢出。</p>
</blockquote>

<p><strong>函数调用栈如下：</strong><a href="https://blog.csdn.net/wangyezi19930928/article/details/16921927">link</a>
<img src="./2019-10-30-C++review-png/1571279058161.png" alt="Alt text" /></p>

<h4 id="23跨平台是怎么实现的为什么能跨平台">23、跨平台是怎么实现的，为什么能跨平台</h4>
<blockquote>
  <p>C#，java跨平台，指的是，经过“编译系统” 编译，生成中间文件“字节码”，这样的字节码经过不同平台“解释器”再解释一次，就变成了适应各个平台的“机器码”。是建立在“虚拟机”的基础上的，通过虚拟机，将字节码 通过“解释器”，解释成 机器码。
支持C++语言的各个平台的架构不同（比如CPU能够处理的指令集不一样），所以一份C++源代码要想在另一个操作系统平台上执行，就必须用该平台相对应的C++代码编译器对C++源代码重新进行编译，生成该平台可以直接执行的机器代码。
 它的执行过程是：预处理-&gt;编译-&gt;汇编-&gt;链接-&gt;机器码
 由于C/C++不受虚拟机限制，一份同样的源程序，只需要在每个不同的平台重新编译一次，就可以在各种平台上运行应用程序。而java则是编译一次，然后放到不同平台的java虚拟机上运行!
 java，C#是解释性语言，而C、C++是编译性语言。</p>
</blockquote>

<p><strong>C++源文件从文本到可执行文件经历的过程</strong></p>
<blockquote>
  <p>对于C/C++编写的程序，从源代码到可执行文件，一般经过下面四个步骤：
1).预处理，产生.ii文件
a.对所有的“#define”进行宏展开；
b.处理所有的条件编译指令，比如“#if”,“#ifdef”，“#elif”，“#else”,“#endif”
c.处理“#include”指令，这个过程是递归的，也就是说被包含的文件可能还包含其他文件
d.删除所有的注释“//”和“/**/”
e.添加行号和文件标识
f.保留所有的“#pragma”编译器指令
    经过预处理后的.ii文件不包含任何宏定义，因为所有的宏已经被展开，并且包含的文件也已经被插入到.ii文件中。</p>
</blockquote>

<blockquote>
  <p>2).编译，产生汇编文件(.s文件)
编译的过程就是将预处理完的文件进行一系列词法分析，语义分析及优化后生成相应的汇编代码文件(.s文件)</p>
</blockquote>

<blockquote>
  <p>3).汇编，产生目标文件(.o或.obj文件)
汇编是将汇编代码转变成机器可以执行的代码，每一个汇编语句几乎都对应一条机器指令。最终产生目标文件(.o或.obj文件)。
目标文件由段组成，通常一个目标文件中至少有两个段：
代码段：该段中所包含的主要是程序的指令。该段一般是可读和可执行的，但一般却不可写。
数据段：主要存放程序中要用到的各种全局变量或静态的数据。一般数据段都是可读，可写，可执行的。</p>
</blockquote>

<blockquote>
  <p>4).链接,产生可执行文件(.out或.exe文件)
链接就是把每个源代码独立的编译，然后按照它们的要求将它们组装起来，链接主要解决的是源代码之间的相互依赖问题. 链接的过程主要包括了地址和空间分配(Address and Storage Allocation)、符号决议(Symbol Resolution)和重定位(Relocation)
静态链接：在链接阶段，会将汇编生成的目标文件.o与引用到的库一起链接打包到可执行文件中，因此对应的链接方式称为静态链接。
静态库的缺点在于：浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。
动态链接：动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入。不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题。动态库在程序运行是才被载入，也解决了静态库对程序的更新、部署和发布页会带来麻烦。用户只需要更新动态库即可，增量更新。</p>
</blockquote>

<h4 id="24gcc和vs的区别是什么">24、gcc和vs的区别是什么??</h4>

<p><strong>gcc与g++</strong></p>
<blockquote>
  <p>gcc: GNU C Compiler
g++: GNU C++ Compiler
g++ == gcc -xc++ -lstdc++ -shared-libgcc
1.后缀为.c的，gcc把它当作是C程序，而g++当作是c++程序；后缀为.cpp的，两者都会认为是c++程序
2.编译阶段，g++会调用gcc，对于c++代码，两者是等价的，但是因为gcc命令不能自动和C＋＋程序使用的库联接，所以通常用g++来完成链接，为了统一起见，干脆编译/链接统统用g++了，这就给人一种错觉，好像cpp程序只能用g++似的。
编译可以用gcc/g++，而链接可以用g++或者gcc -lstdc++。因为gcc命令不能自动和C＋＋程序使用的库联接，所以通常使用g++来完成联接。但在编译阶段，g++会自动调用gcc，二者等价。</p>
</blockquote>

<h4 id="25socket编程">25、socket编程</h4>

<h4 id="26进程线程调度和通信">26、进程、线程调度和通信</h4>

<h4 id="27定义和声明区别">27、定义和声明区别</h4>
<blockquote>
  <p>1.定义和声明的简单说明
a.声明就是指给出了当前变量或者函数，或者类什么的名字，不给其中的内容，就是先告诉你有这样一个什么类型的变量或者函数
b.定义就不一样了，定义直接告诉你了所有的东西，这个变量是什么，这个函数是什么功能，这个类里面包含了什么东西。很具体的说明。
2.对于变量来说
a.定义：可以为变量分配存储空间，并且可以给变量一个初始值
b.声明：告诉编译器这个变量的名字和类型（extern int a;(在没有赋值的情况下，变量前加上关键字extern一定为声明)）
3.对于函数来说
a.定义：就是这个函数具体的实现
b.声明：告诉编译器在这个程序中会有这么一个函数
简单来说，如果函数带有{}，则其为定义；否则，就为声明。</p>
</blockquote>

<blockquote>
  <p>二.深入探讨
1.在一个程序中只能对变量定义一次，因为我们不能让编译器一直为同一个变量，函数分配不同的存储空间；而可以对变量进行很多次的声明。
2.在任何多文件中使用的变量都需要有与定义分离的声明。在这种情况下，一文件含有变量的定义，则使用该变量的其他文件中就要含有该变量的声明，而不是定义。
3.在头文件中不能放变量的定义，一般存放变量的声明。因为头文件要被其他文件包含，如果放到头文件当中就不能避免变量被多次定义。（const，inline）</p>
</blockquote>

<h4 id="28camke">28、camke</h4>

<h4 id="29python和c有什么区别">29、python和C++有什么区别</h4>
<blockquote>
  <p><strong>运行效率：C++ » Python</strong>
首先，Python东西比C++多，经过了更多层，Python中甚至连数字都是object !!!
其次，Python是解释执行的，和物理机CPU之间多了解释器这层，而C++是编译执行的，直接就是机器码，编译的时候编译器又可以进行一些优化。
<strong>开发效率：Python » C++</strong>
<strong>书写格式和语法不同</strong>
<strong>生态库不同</strong>：Python开源</p>
</blockquote>

<p>####30、如何判断内存泄漏<a href="https://blog.csdn.net/qq_41786318/article/details/81838359">link</a></p>
<blockquote>
  <p>检测内存泄漏的关键原理就是，检查malloc/new和free/delete是否匹配，一些工具也就是这个原理。要做到这点，就是利用宏或者钩子，在用户程序与运行库之间加了一层，用于记录内存分配情况。
<strong>Windows平台</strong>下面Visual Studio 调试器和 C 运行时 (CRT) 库为我们提供了检测和识别内存泄漏的有效方法，原理大致如下：内存分配要通过CRT在运行时实现，只要在分配内存和释放内存时分别做好记录，程序结束时对比分配内存和释放内存的记录就可以确定是不是有内存泄漏。
STEP1，在程序中包括以下语句：</p>
  <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#define _CRTDBG_MAP_ALLOC
#include &lt;stdlib.h&gt;
#include &lt;crtdbg.h&gt;
</code></pre></div>  </div>
  <p>STEP2， 在添加了上述语句之后，可以通过在程序中包括以下语句（通常应恰好放在程序退出位置之前）来转储内存泄漏信息：<code class="highlighter-rouge">_CrtDumpMemoryLeaks();</code>
<strong>Linux</strong>下面也有原理相同的方法——mtrace, 可使用Valgrind工具</p>

</blockquote>

<p>####31、线程之间共享什么</p>
<blockquote>
  <p>a. 堆  由于堆是在进程空间中开辟出来的，所以它是理所当然地被共享的；因此new出来的都是共享的（16位平台上分全局堆和局部堆，局部堆是独享的）
b. 全局变量 它是与具体某一函数无关的，所以也与特定线程无关；因此也是共享的
c. 静态变量 虽然对于局部变量来说，它在代码中是“放”在某一函数中的，但是其存放位置和全局变量一样，存于堆中开辟的.bss和.data段，是共享的
d. 文件等公用资源  这个是共享的，使用这些公共资源的线程必须同步。Win32 提供了几种同步资源的方式，包括信号、临界区、事件和互斥体。
独享的资源有
a. 栈 栈是独享的
b. 寄存器  这个可能会误解，因为电脑的寄存器是物理的，每个线程去取值难道不一样吗？其实线程里存放的是副本，包括程序计数器PC</p>
</blockquote>

<blockquote>
  <p><strong>线程共享的环境包括：</strong>
进程代码段、进程的公有数据(利用这些共享的数据，线程很容易的实现相互之间的通讯)、进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID。</p>
</blockquote>

<blockquote>
  <p>线程程拥有这许多共性的同时，还拥有自己的个性。有了这些个性，线程才能实现并发性。
这些个性包括：
1.线程ID
　　每个线程都有自己的线程ID，这个ID在本进程中是唯一的。进程用此来标识线程。 
2.寄存器组的值
　　由于线程间是并发运行的，每个线程有自己不同的运行线索，当从一个线 程切换到另一个线程上 时，必须将原有的线程的寄存器集合的状态保存，以便将来该线程在被重新切换到时能得以恢复。
3.线程的堆栈
　　堆栈是保证线程独立运行所必须的。线程函数可以调用函数，而被调用函数中又是可以层层嵌套的，所以线程必须拥有自己的函数堆栈， 使得函数调用可以正常执行，不受其他线程的影响。
4.错误返回码
      由于同一个进程中有很多个线程在同时运行，可能某个线程进行系统调用 后设置了errno值，而在该 线程还没有处理这个错误，另外一个线程就在此时被调度器投入运行，这样错误值就有可能被修改。所以不同线程应该有自己的错误返回码变量。
5.线程的信号屏蔽码
　　由于每个线程所感兴趣的信号不同，所以线程的信号屏蔽码应该由线程自己管理。但所有的线程都 共享同样的信号处理器。
6.线程的优先级
　　由于线程需要像进程那样能够被调度，那么就必须要有可供调度使用的参数，这个参数就是线程的 优先级。</p>
</blockquote>

<h4 id="32异常处理">32、异常处理</h4>
<p><a href="https://blog.csdn.net/zhangye3017/article/details/80299562">原文链接</a>
<strong>异常处理的语句</strong></p>
<blockquote>
  <p>try区段：这个区段中包含了可能发生异常的代码，在发生了异常之后，需要通过throw抛出。
throw子句：throw 子句用于抛出异常，被抛出的异常可以是C++的内置类型（例如： throw int(1);），也可以是自定义类型。
catch子句：每个catch子句都代表着一种异常的处理。catch子句用于处理特定类型的异常。</p>
</blockquote>

<p><strong>异常处理规则</strong></p>
<blockquote>
  <p>异常是通过抛出对象而引发的，该对象的类型决定了应该激活哪个处理代码。
被选中的处理代码是调用链中与该对象类型匹配且离抛出异常位置最近的那一个。
抛出异常后会释放局部存储对象，所以被抛出的对象也就还给系统了，throw表达式会初始化一个抛出特殊的匿名对象，异常对象由编译管理，异常对象在传给对应的catch处理之后撤销</p>
</blockquote>

<p><strong>异常处理栈展开</strong></p>
<blockquote>
  <ol>
    <li>在try的语句块内声明的变量在外部是不可以访问的，即使是在catch子句内也不可以访问。</li>
    <li>栈展开（寻找异常处理（exception handling）代码）
 栈展开会沿着嵌套函数的调用链不断查找，知道找到了已抛出的异常匹配的catch子句。如果在最后还是没有找到对应的 catch子句的话，则退出主函数后查找过程终止，程序调用标准函数库的terminate()函数，终止该程序的执行.
具体过程：
      <blockquote>
        <p>当一个exception被抛出的时候，控制权会从函数调用中释放出来，并需找一个可以处理的catch子句
对于一个抛出异常的try区段，程序会先检查与该try区段关联的catch子句，如果找到了匹配的catch子句，就使用这个catch子句处理这个异常。
没有找到匹配的catch子句，如果这个try区段嵌套在其他try区段中，则继续检查与外层try匹配的catch子句。如果仍然没有找到匹配的catch子句，则退出当前这个主调函数，并在调用了刚刚退出的这个函数的其他函数中寻找。</p>
      </blockquote>
    </li>
  </ol>
</blockquote>

<blockquote>
  <ol>
    <li>catch子句的查找：
     catch子句是按照出现的顺序进行匹配的（以例2来说，异常先会匹配catch(exception e)子句，然后在匹配 catch (Exception e)子句，一步一步的栈展开）。在寻找catch子句的过程中，抛出的异常可以进行类型转换，但是比较严格：
      <ul>
        <li>允许从非常量转换到常量的类型转换（权限缩小）</li>
        <li>允许从派生类到基类的转换。</li>
        <li>允许数组被转换成为指向数组（元素）类型的指针，函数被转换成指向该函数类型的指针（降级问题）</li>
        <li>标准算术类型的转换（比如：把bool型和char型转换成int型）和类类型转换(使用类的类型转换运算符和转换构造函数)。</li>
      </ul>
    </li>
  </ol>
</blockquote>

<p><strong>异常处理中需要注意的问题</strong></p>
<blockquote>
  <ul>
    <li>如果抛出的异常一直没有函数捕获(catch)，则会一直上传到c++运行系统那里，导致整个程序的终止</li>
    <li>一般在异常抛出后资源可以正常被释放，但注意如果在类的构造函数中抛出异常，系统是不会调用它的析构函数的，处理方法是：如果在构造函数中要抛出异常，则在抛出前要记得删除申请的资源。</li>
    <li>异常处理仅仅通过类型而不是通过值来匹配的，所以catch块的参数可以没有参数名称，只需要参数类型。</li>
    <li>函数原型中的异常说明要与实现中的异常说明一致，否则容易引起异常冲突。</li>
    <li>应该在throw语句后写上异常对象时，throw先通过Copy构造函数构造一个新对象，再把该新对象传递给 catch.
　注：那么当异常抛出后新对象如何释放？
　异常处理机制保证：异常抛出的新对象并非创建在函数栈上，而是创建在专用的异常栈上，因此它才可以跨接多个函数而传递到上层，否则在栈清空的过程中就会被销毁。所有从try到throw语句之间构造起来的对象的析构函数将被自动调用。但如果一直上溯到main函数后还没有找到匹配的catch块，那么系统调用terminate()终止整个程序，这种情况下不能保证所有局部对象会被正确地销毁。</li>
    <li>catch块的参数推荐采用地址传递而不是值传递，不仅可以提高效率，还可以利用对象的多态性。另外，派生类的异常扑获要放到父类异常扑获的前面，否则，派生类的异常无法被扑获。</li>
    <li>编写异常说明时，要确保派生类成员函数的异常说明和基类成员函数的异常说明一致，即派生类改写的虚函数的异常说明至少要和对应的基类虚函数的异常说明相同，甚至更加严格，更特殊。</li>
  </ul>
</blockquote>

<p>####33、TCP 、UDP 
<a href="https://blog.csdn.net/zhang6223284/article/details/81414149">link</a></p>

<p><strong>UDP(User Datagram Protocol用户数据报协议)</strong>
<img src="./2019-10-30-C++review-png/1571665500501.png" alt="Alt text" /></p>
<blockquote>
  <p>传输层，无连接，简单不可靠
UDP 除了端口号，基本啥都没有了。如果没有这两个端口号，数据就不知道该发给哪个应用。
<strong>特点</strong></p>
  <ul>
    <li>沟通简单，不需要大量的数据结构，处理逻辑和包头字段</li>
    <li>轻信他人。它不会建立连接，但是会监听这个地方，谁都可以传给它数据，它也可以传给任何人数据，甚至可以同时传给多个人数据。</li>
    <li>愣头青，做事不懂变通。不会根据网络的情况进行拥塞控制，无论是否丢包，它该怎么发还是怎么发</li>
  </ul>

  <p><strong>应用场景</strong></p>
  <ul>
    <li>需要资源少，网络情况稳定的内网，或者对于丢包不敏感的应用，比如 DHCP 就是基于 UDP 协议的。</li>
    <li>不需要一对一沟通，建立连接，而是可以广播的应用。因为它不面向连接，所以可以做到一对多，承担广播或者多播的协议。</li>
    <li>需要处理速度快，可以容忍丢包，但是即使网络拥塞，也毫不退缩，一往无前的时候
<strong>例子：</strong>直播、实时游戏、物联网</li>
  </ul>
</blockquote>

<p><strong>TCP(Transmission Control Protocol传输控制协议）</strong>
<img src="./2019-10-30-C++review-png/1571665845948.png" alt="Alt text" /></p>

<blockquote>
  <p>面向连接的，可靠的，基于字节流的传输通信协议。传输层
<strong>三次握手</strong>
 <img src="./2019-10-30-C++review-png/1571665867045.png" alt="Alt text" /></p>
</blockquote>

<blockquote>
  <p><strong>四次挥手</strong>
<img src="./2019-10-30-C++review-png/1571665881677.png" alt="Alt text" /></p>
</blockquote>

<p><strong>两者的区别</strong></p>
<blockquote>
  <p>1、TCP是面向连接的（在客户端和服务器之间传输数据之前要先建立连接），UDP是无连接的（发送数据之前不需要先建立连接）
2、TCP提供可靠的服务（通过TCP传输的数据。无差错，不丢失，不重复，且按序到达）；UDP提供面向事务的简单的不可靠的传输。
3、UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性比较高的通讯或广播通信。随着网速的提高，UDP使用越来越多。
4、每一条TCP连接只能是点到点的，UDP支持一对一，一对多和多对多的交互通信。
5、TCP对系统资源要去比较多，UDP对系统资源要求比较少
6、UDP程序结构更加简单
7、TCP是流模式，UDP是数据报模式</p>
</blockquote>

<p>为什么TCP是可靠的？</p>
<blockquote>
  <ul>
    <li>通过 TCP 连接传输的数据无差错，不丢失，不重复，且按顺序到达。</li>
    <li>TCP 报文头里面的序号能使 TCP 的数据按序到达</li>
    <li>报文头里面的确认序号能保证不丢包，累计确认及超时重传机制</li>
    <li>TCP 拥有流量控制及拥塞控制的机制</li>
  </ul>
</blockquote>

<p>####34、设计模式  Redis</p>

<p>####35、git、shell命令
<a href="https://www.runoob.com/linux/linux-shell.html"><strong>shell</strong></a>
<a href="https://git-scm.com/book/zh/v2"><strong>git</strong></a></p>
<h4 id="36include头文件的顺序以及双引号和尖括号的区别">36、include头文件的顺序以及双引号””和尖括号的区别</h4>
<blockquote>
  <p>简单区分：
1，系统自带的头文件用尖括号括起来，这样编译器会在系统文件目录下查找。 
<code class="highlighter-rouge">#include &lt;xxx.h&gt;</code>
2，用户自定义的文件用双引号括起来，编译器首先会在用户目录下查找，然后在到C++安装目录（比如VC中可以指定和修改库文件查找路径，Unix和Linux中可以通过环境变量来设定）中查找，最后在系统文件中查找。 
<code class="highlighter-rouge">#include “xxx.h”</code>
尽管以上两种#include命令都可以正确地被VC++识别了，但是它们却并不符合C++的标准。标准规定，包含C++提供的标准头文件或系统头文件时应使用尖括号，包含自定义头文件时可使用双引号。</p>
</blockquote>

<p><strong>段错误</strong></p>
<blockquote>
  <p>是指程序访问(读写)了系统未给予读写权限的内存空间(栈溢出或数组溢出)。包括:访问了不存在的内存空间,访问了系统保护的空间，对只读内存空间写覆盖等，常见的形式有数组越界访问，野指针操作等.</p>
</blockquote>

:ET