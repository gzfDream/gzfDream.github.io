---
layout: post
title:  每天一道算法题(2)
date:   2019-11-4 11:00:50 +0800
categories: 手撕代码
tags: c++ LeetCode algorithm
author: gzf
excerpt: 每天一道算法题
mathjax: true
---


## 1、 划分为k个相等的子集
### 题目描述 
给定一个整数数组  nums 和一个正整数 k，找出是否有可能把这个数组分成 k 个非空子集，其总和都相等。[来源：力扣（LeetCode）](https://leetcode-cn.com/problems/partition-to-k-equal-sum-subsets)
#### 样例
>输入： nums = [4, 3, 2, 3, 5, 2, 1], k = 4
>
> 输出： True
>
> 说明： 有可能将其分成 4 个子集（5），（1,4），（2,3），（2,3）等于总和。
>

#### 思路：
- 递归，回溯

```cpp
	bool helper(const vector<int>& nums, int start, vector<int>&sums, int target){
		// 输入 原数组，原数组中开始搜索的位置，每个子数组的和，目标和
        if(start>=nums.size()){
            for(int i=0; i<k; i++){
                if(sums[i]!=target)
                    return false;
            }   
            return true;
        }
        
        for(int j=0; j<sums.size(); j++){
            if(nums[start]>target)
                return false;
            if(nums[start]+sums[j]<=target){
                sums[j]+=nums[start];
                if(helper(nums, start+1, sums, target))
                    return true;
                sums[j]-=nums[start];
            }else{
                continue;
            }
        }
        return false;
    }

    bool canPartitionKSubsets(vector<int>& nums, int k) {
        int sum=0;
        for(int i=0; i<nums.size(); i++){  // 求和
            sum+=nums[i];
        }
        
        if(sum%k != 0) // 如果不能整除，一定不成立
            return false;
        else  // 如果可以整除，计算每个子数组的目标和
            sum/=k;
        
        sort(nums.rbegin(), nums.rend());  // 从大到小排序
        
        vector<int>sums(k,0);  // 存放k个子数组的和
        return helper(nums, 0, sums, sum);
    }
```

## 2 N叉树的层序遍历
**题目描述**
> 给定一个 N 叉树，返回其节点值的层序遍历。 (即从左到右，逐层遍历)。[来源：力扣(LeetCode)](https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/)

```cpp
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
```

**思路**
> - 使用queue迭代
>
> - 递归bfs

```cpp
// 迭代
vector<vector<int>> levelOrder(Node* root) {
    vector<vector<int>> result;
        
    if(root==NULL)
        return result;

    queue<Node*>que;
    que.push(root);

    while(!que.empty()){
        vector<int> vec;
        queue<Node*>q_tmp;
        while(!que.empty()){
            Node* p = que.front();
            que.pop();
            vec.push_back(p->val);
            for(int i=0; i<p->children.size(); i++)
                q_tmp.push(p->children[i]);
        }   
        result.push_back(vec);
        que=q_tmp;
    }
    return result;
}
```
----
```cpp
// 递归
    void helper(Node* root, int level, vector<vector<int>>&vec){
        if(root==NULL)
            return;
        
        if(level+1>vec.size()){
            vec.push_back(vector<int>{});   
        }
        
        vec[level].push_back(root->val);
        for(int i=0; i<root->children.size(); i++){
            if(root->children[i]!=NULL){
                helper(root->children[i], level+1, vec);
            }
        }
    }
    vector<vector<int>> levelOrder(Node* root) {
        //递归
        vector<vector<int>> res;
        if(root==NULL)
            return res;
        
        helper(root, 0, res);
        
        return res;
        
    }

```
