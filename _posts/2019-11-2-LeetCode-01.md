---
layout: post
title:  每天一道算法题（1）
date:   2019-10-31 11:00:50 +0800
categories: 手撕代码
tags: c++ LeetCode algorithm
author: gzf
excerpt: 每天一道算法题
mathjax: true
---

## 1、和相同的二元子数组 
### 题目描述 
在由若干 0 和 1  组成的数组 A 中，有多少个和为 S 的非空子数组。[来源：力扣（LeetCode）](https://leetcode-cn.com/problems/binary-subarrays-with-sum)
#### 样例
> 输入：A = [1,0,1,0,1], S = 2 
> 
> 输出：4
>
> 解释：
>
> 如下面黑体所示，有 4 个满足题目要求的子数组：
>
> [1,0,1,0,1]
>
> [1,0,1,0,1]
>
> [1,0,1,0,1]
>
> [1,0,1,0,1]

#### 思路[参考](https://leetcode-cn.com/problems/binary-subarrays-with-sum/solution/c-he-xiang-tong-de-er-yuan-zi-shu-zu-by-sologala/)：
- 当S=0时，只需要计算全为0的连续子数组。
- 当S!=0时，对于一个和等于S的子数组，可以求出第一个1 左边的0的个数，以及最后一个 1 的右边的 0 的个数 然后它们相乘 就是的当前这两个1 构成 s的所有总类。

```cpp
int numSubarraysWithSum(vector<int>& A, int S) {
        int result=0;
        if(S==0){
            int len=0;
            for(int i=0; i<A.size(); i++){
                if(A[i]==0){
                    len++;
                }else{
                    result+=(((len+1)*len)/2);
                    len=0;
                }
            }
            result+=(((len+1)*len)/2);
        }
        else{
            int start=0;
            int end=0;
            int sum=0;
            for(int i=0; i<A.size(); i++){
                if(A[i]==1){
                    start=i;
                    end=start;
                    sum=0;
                    bool flag=false;
                    for(; end<A.size(); end++){
                        sum+=A[end];
                        if(sum==S){
                            flag=true;
                            break;
                        }
                    }
                    if(flag){
                        int left=1;
                        int right=1;
                        for(int j=start-1; j>=0; j--){
                            if(A[j]==0)
                                left++;
                            else
                                break;
                        }

                        for(int j=end+1; j<A.size(); j++){
                            if(A[j]==0)
                                right++;
                            else
                                break;
                        }
                        result+=left*right;
                    }
                }
            }
        }
        
        return result;
    }

```


## 2、计算各个位数不同的数字个数
### 题目描述
给定一个非负整数 n，计算各位数字都不同的数字 x 的个数，其中 0 ≤ x < 10n 。[来源：力扣（LeetCode）](https://leetcode-cn.com/problems/count-numbers-with-unique-digits/)
> 输入: 2
>
> 输出: 91 
>
> 解释: 答案应为除去 11,22,33,44,55,66,77,88,99 外，在 [0,100) 区间内的所有数字。

<details>
<summary>code</summary>
<pre><code>

	int numSubarraysWithSum(vector<int>& A, int S) {
        int result=0;
        if(S==0){
            int len=0;
            for(int i=0; i<A.size(); i++){
                if(A[i]==0){
                    len++;
                }else{
                    result+=(((len+1)*len)/2);
                    len=0;
                }
            }
            result+=(((len+1)*len)/2);
        }
        else{
            int start=0;
            int end=0;
            int sum=0;
            for(int i=0; i<A.size(); i++){
                if(A[i]==1){
                    start=i;
                    end=start;
                    sum=0;
                    bool flag=false;
                    for(; end<A.size(); end++){
                        sum+=A[end];
                        if(sum==S){
                            flag=true;
                            break;
                        }
                    }
                    if(flag){
                        int left=1;
                        int right=1;
                        for(int j=start-1; j>=0; j--){
                            if(A[j]==0)
                                left++;
                            else
                                break;
                        }
                        for(int j=end+1; j<A.size(); j++){
                            if(A[j]==0)
                                right++;
                            else
                                break;
                        }
                        result+=left*right;
                    }
                }
            }
        }
        return result;
    }
</code></pre>
</details>